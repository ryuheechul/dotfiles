# vim: set ft=zsh:

function _tag {
  return # comment here to debug performance
  echo shell_ext $1
  date +%s%N
}

_tag start

# use cache to reduce number of export to speed up
path_cache="${PATH}"

function cache-path {
  path_cache="${1}:${path_cache}"
}

function evalcache-clear {
  yes | _evalcache_clear
}

# to make it consumable for _evalcache
function _evalable {
  # echo is the key to make it consumable
  # subshell substituting is the key to cache the result
  print "echo -n '$(${@})'"

  # meaningless example of this function would be be low which was my mistake in the past
  # echo "$@"
}

# alternative to call _evalable arch directly to produce better filename for cached results
function _evalable_arch {
  _evalable arch
}

function _evalable_fzf_share {
  _evalable fzf-share
}

function _evalable_brew_prefix {
  _evalable brew --prefix
}

function _evalable_path_grep_nix_profile {
  function _path_grep_nix_profile {
    path | grep nix-profile
  }

  _evalable _path_grep_nix_profile
}

function _evalable_yarn_global_path {
  _evalable yarn global bin
}

function _evalable_vivid_generate_solarized_light {
  _evalable vivid generate solarized-light
}

_tag fn-def

_arch="$(_evalcache _evalable_arch)"

# intel chip (at least not powerful ones) can't seem to handle this, so disabled for them for now
test "${_arch}" = "arm64" && {
  export my_zsh_plugin_zsh_autocomplete=1;
  export my_nvim_ghost=1;
  export my_nvim_tabnine=1;
}

# currently it bring very poor performance issue so turning it off for now
unset my_zsh_plugin_zsh_autocomplete;

_tag arch

# theme for bat
export BAT_THEME="Solarized (light)"
# set it as env var here instead of ~/.config/bat/config as the issue is described in the file
export BAT_PAGER="less --RAW-CONTROL-CHARS --quit-if-one-screen --mouse -I"

# set LS_COLORS with vivid
if test -n "${commands[vivid]}"; then
  export LS_COLORS="$(_evalcache _evalable_vivid_generate_solarized_light)"
fi

_tag vivid

# fzf + fd # fd ignores .gitignore files/directories by default
# default
export FZF_DEFAULT_COMMAND='fd --type f'
# color is based on https://github.com/junegunn/fzf/wiki/Color-schemes#solarized-light
export FZF_DEFAULT_OPTS='
  --height 40%
  --layout=reverse
  --color fg:240,hl:33,fg+:241,bg+:221,hl+:33
  --color info:33,prompt:33,pointer:166,marker:166,spinner:33
  '

# CTRL-T - Paste the selected files and directories onto the command-line
export FZF_CTRL_T_COMMAND='fd'
export FZF_CTRL_T_OPTS=''

# ALT-C - cd into the selected directory
export FZF_ALT_C_COMMAND='fd -t d'
export FZF_ALT_C_OPTS=''

# better history search with fzf via https://nixos.wiki/wiki/Fzf

if test -n "${commands[fzf-share]}"; then
  path_from_fzf_share="$(_evalcache _evalable_fzf_share)"
  source "${path_from_fzf_share}/key-bindings.zsh"
  source "${path_from_fzf_share}/completion.zsh"
else # falling back to brew
  # in case of enabling with brew via https://github.com/junegunn/fzf#using-homebrew
  if test -n "${commands[brew]}"; then
    [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
    # configuring completions for brew installed packages
    # this FPATH will be needed in ../zshrc and should be accessible this way too
    FPATH="$(_evalcache _evalable_brew_prefix)/share/zsh/site-functions:$FPATH"
  fi
fi

_tag fzf

## binaries by language global packages, for example, npm, rust, go, etc.

# making sure it supersedes like /bin /usr/bin /usr/local/bin
cache-path "$(_evalcache _evalable_path_grep_nix_profile)"

_tag nix-path

# rust
if test -n "${commands[cargo]}"; then
  cache-path "${HOME}/.cargo/bin"
fi

_tag cargo

# golang
if test -n "${commands[go]}"; then
  export GOPATH=${HOME}/go
  cache-path "${GOPATH}/bin"
fi

_tag go

# yarn
if test -n "${commands[yarn]}"; then
  # because yarn global bin is slow
  cache-path "$(_evalcache _evalable_yarn_global_path)"
fi

_tag yarn

# asdf
ASDF_DIR="${ASDF_DIR:-${HOME}/.asdf}"
# https://github.com/asdf-vm/asdf - version manager
[ -f "${ASDF_DIR}/asdf.sh" ] && source "${ASDF_DIR}/asdf.sh"

_tag asdf

# discover user specific binaries and scripts
cache-path "${HOME}/.local/bin"

# add ../../bin/local
cache-path "${HOME}/.config/dfs-rhc/bin/discoverable"

# actually this wouldn't work.
# so bootstrap script should be at its own repo
# and that should be sourced
# ---
# https://github.com/ryuheechul/bin will be clone to this
cache-path "${HOME}/.local/my-bin"

export PATH="${path_cache}"
_tag flush-path

_tag path

# starship
_evalcache starship init zsh

_tag starship

# use direnv
[ $commands[direnv] ] && _evalcache direnv hook zsh

_tag direnv

# for https://github.com/aykamko/tag
if (( $+commands[tag] )); then
  export TAG_SEARCH_PROG=ag
  tag() { command tag "$@"; source ${TAG_ALIAS_FILE:-/tmp/tag_aliases} 2>/dev/null }
  alias ag=tag
fi

_tag tag

# fallback any command to npx # disabled for now
# source <(npx --shell-auto-fallback zsh)

# only load base16-shell when it's not opened via SSH
if test -z "${SSH_TTY}" ; then
  BASE16_SHELL="${HOME}/.config/base16-shell"
  [ -n "${PS1}" ] && \
      [ -s "${BASE16_SHELL}/profile_helper.sh" ] && \
          _evalcache ${BASE16_SHELL}/profile_helper.sh

  # shim to workaround the issue with cached result of above
  export BASE16_THEME="$(current-base16)"

  # helper functions to make theme tone changes and that to be followable by other tools
  _update_theme_changed_time() {
    # let external tools to have a chance to follow the change and adopt to it
    date +%s > ~/.base16_theme.updated-time
  }
  source ~/.base16_theme
fi

# TODO: DRY `light` and `dark`

light() {
  if test -z "${SSH_TTY}"; then
    base16_solarized-light
    _update_theme_changed_time
  else
    echo 'base16-shell was not loaded given that the shell appears to be opened via SSH'
  fi
}

dark() {
  if test -z "${SSH_TTY}"; then
    base16_solarized-dark
    _update_theme_changed_time
  else
    echo 'base16-shell was not loaded given that the shell appears to be opened via SSH'
  fi
}

_tag base16

# extra things to load for emacs for possible shell integration
if test -n "${INSIDE_EMACS}"; then
  to_source_for_emacs=~/.config/dfs-rhc/emacs.d/shell/source.zsh
  test -f ${to_source_for_emacs} && source ${to_source_for_emacs}
fi

_tag emacs

unfunction _tag
